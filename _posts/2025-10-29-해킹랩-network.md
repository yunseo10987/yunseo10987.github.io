---
title: "[2025-10-29] 네트워크 해킹"
excerpt: "유선 네트워크 해킹: 패킷 캡처"

categories:
  - Lab
tags:
  - [NetWork]

permalink: /Lab/[2025-10-29] 네트워크 해킹/

toc: true
toc_sticky: true

date: 2025-10-29
last_modified_at: 2025-10-29
---

## 🦥 본문

## 와이어샤크를 이용한 패킷 캡처

### 와이어 샤크 설치

```bash
sudo apt install wireshark
```

### promiscuous 모드 설정

패킷 캡처하기 위해 네트워크 어댑터를 promiscuous 모드로 설정해야 함. 

[와이어샤크 메뉴] - [Capture] - [Option]에서 enable promiscuous 모드로 설정했는 지 확인 

### 시작 및 캡처

- 기본 사용법 : 프로그램 표시에서 실행 또는 다음 코드 터미널에 입력

```bash
wireshark
```

- 오류 표시 무시 : 보안 상의 이유로 오류 창이 나오는 경우 다음과 같이 파일 변경

```bash
/user/share/wireshark/init.lua

disable_lua = true4
```

- 캡처 시작
    
    [Capture] - [Options]에서 캡처할 네트워크 어댑터 eth1 선택. 캡처 진행 후 파이어폭스를 들어가면 다음과 같은 화면이 나옴
    
    ![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image.png)
    
    - 패킷  필터링
        
        HTTP 패킷 살펴보기 : filter에서 http를 넣어서 http 패킷을 확인
        
        OSCP는 공개키 증명서의 실효 상태를 취득하기 위한 통신 프로토콜, POST 메소드 사용 
        
        `http.request.method == ‘GET’`을 통해 GET 메소드만 필터링 가능 
        
    - 표시 필터 구문
        
        
        | **필터 구문** | **설명** |
        | --- | --- |
        | `http.request` | 모든 HTTP 요청(GET, POST 등) 패킷 표시 |
        | `http.response.code == 404` | HTTP 404 응답 코드 패킷 표시 |
        | `tcp.flags.reset == 1` | 모든 TCP RST(재설정) 플래그가 설정된 패킷 표시 (연결 종료/강제 종료 시 확인) |
        | `tcp.flags.syn == 1 && tcp.flags.ack == 0` | 모든 SYN 패킷 표시 (TCP 3-way-handshake의 첫 단계) |
        | `data` | 페이로드(Payload)에 데이터가 포함된 패킷 표시 (ARP, ICMP 등 제어 프로토콜 제외) |
        | `frame.len > 100` | 전체 프레임 길이가 100바이트를 초과하는 패킷 표시 |
        
        | **종류** | **필터 구문** | **설명** |
        | --- | --- | --- |
        | **특정 IP 주소** | `ip.addr == 192.168.1.100` | 출발지 또는 목적지가 해당 IP인 패킷 표시 |
        | **출발지 IP** | `ip.src == 192.168.1.100` | 출발지 IP가 해당 IP인 패킷만 표시 |
        | **목적지 IP** | `ip.dst == 192.168.1.100` | 목적지 IP가 해당 IP인 패킷만 표시 |
        | **서브넷 필터링** | `ip.addr == 192.168.1.0/24` | 해당 서브넷에 속하는 모든 IP 주소 표시 |
        | **특정 MAC 주소** | `eth.addr == 00:11:22:33:44:55` | 출발지 또는 목적지 MAC 주소가 일치하는 패킷 표시 |
    - 캡처 필터
        
        [Capture] - [Capture filters]에서 적용하고 싶은 캡처 필터를 선택. [+] 추가를 통해 원하는 필터 선택
        
        | **목적** | **캡처 필터 구문** | **설명** |
        | --- | --- | --- |
        | **특정 호스트** | `host 192.168.1.100` | IP 주소가 `192.168.1.100`인 호스트와 관련된 모든 트래픽 캡처 |
        | **특정 포트** | `port 80` | 출발지 또는 목적지 포트가 80인 모든 트래픽 캡처 (HTTP) |
        | **특정 프로토콜** | `tcp` | 모든 TCP 트래픽만 캡처 |
        | **출발지 주소** | `src host 10.0.0.5` | 출발지 IP가 `10.0.0.5`인 트래픽만 캡처 |
        | **목적지 포트** | `dst port 22` | 목적지 포트가 22인 트래픽만 캡처 (SSH) |
        | **특정 MAC 주소** | `ether host 00:11:22:33:44:55` | 해당 MAC 주소와 관련된 모든 트래픽 캡처 |

### 패킷 저장

[File] - [Save as]에서 pcapng 형식으로 캡처 데이터 저장. 

- 데이터  확인
    
    [File] - [Export Packet Dissections] - [As Plain Text]를 선택하여 텍스트 형식으로 내보낼 수 있음 
    
- 스트림 보기
    
    [Analyze] - [Follow]에 [TCP Stream], [UDP Stream] 등이 있음. 원하는 패킷을 선택하여 해당 버튼을 클릭하면 일련의 데이터를 연속해서 보여줌
    
    ![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-1.png)
    
- 파일 데이터 스트림 추출
    1. 직접 추출 : ftp-data를 통해 패킷 필터링. RAW 파일로 저장하는 데 이때 ASCII로 확인할 때 파일 헤더에 MZ라면 확장자를 exe로 지정하는 것이 좋음. 
    2. NetworkMiner 이용 :  pcap 파일을 읽어 들이면 자동으로 파일 식별하여 추출
        1. 사이트에서 NetworkMiner 다운로드 
        2. `unzip networkminer-x` 으로 압축 풀기
        3. NetworkMiner 실행
            
            ```bash
            sudo apt update
            sudo apt install mono-complete 
            
            mono NetworkMiner.exe
            ```
            
    
    이 때 pcappng 파일은 editcap을 통해서 pcap 파일로 분할할 수 있다
    

### 캡쳐 파일 분석: Xplico

- Xplico 설치

```bash
sudo apt install xplico -y
```

- Xplico 웹 페이지 기동 : 설치 완료 시 웹 관리 페이지가 만들어짐. 다음 명령어를 입력하여 아파치를 다시 시작

```bash
sudo service apache2 restart
```

[`http://localhost:9876/`](http://localhost:9876/dp)에 들어가면 다음과 같이 서비스가 시작되지 않았다는 문구가 나옴

![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-2.png)

- 서비스 기동

```bash
/etc/init.d/xplico start
```

- 로그인 : 해당 페이지에 다시 접속하면 로그인 화면이 나옴.
    - admin : {admin, xplico}
    - user : {xplico, xplico}
- 캡쳐 해독 : Case를 만들고 Case내에 여러가지 Session을 만들어 패킷을 분석하고 결과를 표현하도록 만들어짐. Case를 만드는 방법은 **캡처 파일 해독**과 **실시간 캡처 해독**으로 나눠짐
    - [왼쪽 메뉴] - [New case]에서 **DATA ACQUISITION(데이터 해독)**을 선택.
        
        Uploading PCAP capture file/s 이 캡처 파일 해독(파일 지정), Live acquisition이 실시간 해독(인터페이스 지정)
        
        캡쳐 파일 해독을 위해서는 전자를 선택하고 이름과 외부 레퍼런스 입력. 
        
    - 생성된 Case의 Name을 클릭하면 [Session]과 [New Session] 메뉴 생성. [New Session]을 클릭하여 세션 생성. 생성된 세션의 이름을 클릭하면 `Pcap set`에서 [Browse] 버튼을 클릭하여 패킷을 선택해서 업로드할 수 있음
    - [Web] - [https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/Image]에서 캡쳐된 패킷 파일에 포함된 그림 파일을 확인 가능

### 덤프 도구로 데이터 확인

와이어샤크에서는 Flow TCP Stream 화면에서 Hex Dump로 전환하여 덤프 확인

xxd 도구를 통해서도 내용 확인 가능

### nmap의 포트 스캔 분석

nmap을 이용해 TCP SYN 스캔, FIN 스캔, ACK 스캔 등 다양하게 가능 

![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-3.png)

1. 백그라운드에서 캡쳐 시작 : eht0으로 지정

```bash
wireshark &
```

1. TCP full connection 스캔 확인 : nmap의 TCP full connection 스캔 확인
    
    ```bash
    nmap -sT -p 445 10.0.0.1
    //-sT는 TCP Connect Scan. 3way handshake를 완전히 수행하여 포트 상태 확인
    ```
    
    - 와이어샤크에서 ip.addr == 10.0.0.1을 필터링하여 패킷 확인
        
        ![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-4.png)
        
    - [Statistics] - [Flow Graph]를 선택하면 통신 교환 내용을 쉽게 확인
        1. 다음과 같이 연결이 안되는 경우 방화벽 확인 
        
        ![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-5.png)
        
        ```bash
        telnet 10.0.0.1 445
        ```
        
        - 인바운드 규칙 설정
            
            파일 및 프린터 공유(SMB-In) 규칙 사용으로 변경
            
            ![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-6.png)
            
2. TCP SYN 스캔 확인 
    
    ```bash
    nmap -sS -p 445 10.0.0.1
    ```
    
    ![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-7.png)
    
    ACK를 안받고 RST를 보내기 때문에 더 빠름.

### SSL 세션 복원

https://wiki.wireshark.org/SampleCaptures?action=AttachFile&do=view&target=snakeoil2_070531.tgz에서 파일 다운로드 후 .cap 파일 열기

![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-8.png)

HTTPS 패킷은 애플리케이션 데이터가 암호화가 되어 있음. 이를 복호화하기 위해서는 개인키를 등록해야 함 

- 개인 키 등록
1. 개인 키 취득 : 웹 서버의 설정 파일을 참조해 SSL 개인 키의 위치를 확인한 후 SSL 개인 키를 취득 
    - 원래는 웹 서버 관리자만 가능. 다운 받은 파일 중 key 파일이 있음
2. [Edit] - [Preferences] - [Protocol] - [TLS]에서 RSA keys list의 [Edit]에서 설정
    - IP : 127.0.0.1
    - port : 443
    - Protocol : http
    - keyfile 에 파일 경로

## tshark로 패킷 캡처

와이어샤크의 CLI 버전. 와이어샤크가 설치된 환경이면 이미 설치

- 패킷 캡처

```bash
tshark -i eth0 -c 2
```

`-c` 옵션을 통해 2개의 패킷 캡처

- 필터링 방법

```bash
tshark -f "udp port 53" -i eth0 -w traffic.pcap
//DNS 즉, 53번 포트 UDP를 traffic.pcap 이라는 이름으로 출력
```

`-f`옵션을 통해 캡처 필터 지정

## MAC 주소

### MAC 주소 확인 방법

- 윈도우 버전

```bash
ipconfig /all
```

- 리눅스 버전

```bash
ifconfig
또는
ip addr
```

### 패킷에서 MAC 주소

![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-9.png)

Ethernet 헤더 : Frame, Ethernet 부분으로 src MAC addr와 dst MAC addr이 있음

IP 헤더 : srcIP dstIP가 있음

TCP 세그먼트 :  srcPort dstPort가 있음 

## ARP 구조

ARP : IP 주소를 통해 MAC 주소를 알아내는 프로토콜

ARP request : srcIP, srcMAC, dstIP를 설정. dstMAC은 브로드캐스트 주소로 설정하여 브로드캐스팅.

ARP reply : ARP 브로드캐스트를 받은 기기 중 dstIP가 자신의 IP 주소와 맞는 경우 srcMAC에 자신의 MAC 주소를 실어서 보냄

ARP table : IP 주소와 MAC 주소를 캐싱하는 곳. `arp` 명령으로 확인 가능

```bash
//윈도우 
arp -a 

//리눅스
arp
```

### 패킷 형식

![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-10.png)

| **구성 요소** | **바이트 수** | **ARP 요청 (Request)** | **ARP 응답 (Reply)** |
| --- | --- | --- | --- |
| **목적지 MAC 주소** | 6 바이트 | `FF:FF:FF:FF:FF:FF` 고정 (브로드캐스트) | 단말 A의 MAC 주소 |
| **출발지 MAC 주소** | 6 바이트 | 단말 B의 MAC 주소 | 단말 B의 MAC 주소 |
|  |  |  |  |
| **유형** | 2 바이트 | ARP이므로 `0x0806` 고정 |  |
| **데이터** | 46 바이트 | ARP 데이터  |  |
| **하드웨어 유형** | 2 바이트 | Ethernet에서는 `0x0001` 고정 |  |
| **프로토콜 유형** | 2 바이트 | TCP/IP에서는 `0x0800` 고정 |  |
| **하드웨어 길이** | 1 바이트 | MAC 주소의 길이이므로 6 고정 |  |
| **프로토콜 길이** | 1 바이트 | IP 주소의 길이이므로 4 고정 |  |
| **오퍼레이션** | 2 바이트 | 여기서 ARP 요청인지 ARP 응답인지 확인한다. |  |
|  |  |  **1** 고정 (요청) | **2** 고정 (응답) |
| **출발지 하드웨어 주소** | 가변 길이 (실질적 6 바이트) | 출발지 MAC 주소. MAC 주소가 가변 |  |
|  |  | 단말 A의 MAC 주소 | 단말 B의 MAC 주소 |
| **출발지 프로토콜 주소** | 가변 길이 (실질적 4 바이트) | 출**발지 IP 주소**  |  |
|  |  | 단말 A의 **IP** 주소 | 단말 B의 **IP** 주소 |
| 목적지 **하드웨어 주소** | 가변 길이 (실질적 6 바이트) | 목적지 MAC 주소. MAC 주소가 가변 |  |
|  |  | 불명확하기 때문에 `00:00:00:00:00:00` (기본) | **단말 A의 MAC 주소** |
| 목적지 **프로토콜 주소** | 가변 길이 (실질적 4 바이트) | 목적지 **IP 주소**  |  |
|  |  | 단말 B의 **IP** 주소 | 단말 A의 **IP** 주소 |

### 라우터를 경유해 패킷 전송

ARP 프로토콜은 이더넷 브로드 캐스트는 라우터를 넘을 수 없음. GW(기본 게이트웨이)의 IP주소를 알고 있기 때문에 ARP를 통해 GW의 MAC 주소 확인 가능. 

기기가 GW에 이더넷 프레입을 전송하면(즉, dstMAC에 GW의 MAC을 설정) IP 패킷을 확인. IP가 자신이 아니면 도착지 IP 주소로 패킷 전송. 이 때 이더넷 헤더를 붙이고 이더넷 프레임으로 전송해야 하므로 ARP를 사용 후 패킷을 전달.

![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-11.png)

## 스위칭 허브의 학습 기능

스위칭 허브는 물리 주소-MAC 주소 대응 테이블을 사용. 

![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-12.png)

단말 A → 단말 B로 이더넷 프레임을 보낼 때 다음과 같이 동작

1. srcMAC에 AA:… dstMAC에 BB:.. 작성하여 보냄
2. 스위칭 허브는 연결 포트 1로 들어온 이더넷 프레임을 보고 연결 포트 1-AA:.. 를 테이블에 작성
3. BB:..를 모르는 경우 나머지 포트에 이더넷 프레임을 전송
4. 나머지는 버리지만 B는 응답

→ 이런 식으로 B~D를 수행하여 테이블 완성 

## 캡처 방법

### 패시브 캡처

MAC 테이블이 완성된 경우 자신에게 오는 패킷만 캡처 가능. 캡처를 위해서는 출발지에서 캡처 또는 와이어샤크가 작동하는 기기를 네트워크 기기의 포트 미러링 포트에 연결 

- 포트 미러링 : 특정 접속 포트의  통신을 복사해 다른 접속 포트에 전송하는 기능. 공격 탐지 목적은 IDS를 포트 미러링 포트에 연결

패시브 캡처 :  감시 대상의 단말에서 직접 패킷 캡처를  하지 않는 방법 

![image.png](https://yunseo10987.github.io/assets/images/posts_img/2025-10-29%20network/image-13.png)

### 액티브 캡처

패시브 캡처를 시도할 수 있다는 건 이미 침입한 이후라는 것. 굳이 할 필요 없음. ARP 스푸핑 등을 이

액티브 캡처 : 인위적인 통신을 만들어 내거나 일부러 개입해 패킷을 캡처하는 것.